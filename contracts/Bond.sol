// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

// Uncomment this line to use console.log
// import "hardhat/console.sol";

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

contract Bond is ERC20, AutomationCompatibleInterface {
    enum BondState {ACTIVATED, COMPLETED, DEFAULTED}

    uint256 constant _cooldownPeriod = 3 * 1 days;
    uint256 constant _minFaceValue = 1e15; //0.001 ETH

    uint256 immutable _totalQuantity;
    uint256 _purchasedQuantity;
    uint256 immutable _faceValue; //in 10**18
    uint256 immutable _price;
    uint256 immutable _numYears;

    uint256 immutable _startBlock;
    uint256 immutable _maturityBlock;

    address immutable _vault;
    address _owner;

    BondState _currState;

    bool _ownershipTransferred;

    event Completed(address indexed bond, address indexed owner);
    event Defaulted(address indexed bond, address indexed owner);
    

    constructor(
        string memory name_, 
        string memory symbol_,
        uint256 totalQuantity_,
        uint256 faceValue_,
        uint256 price_,
        uint256 numYears_,
        address vault_
        ) ERC20(name_, symbol_){
        require(faceValue_ >= _minFaceValue, "Face value must be greater than 0.01 ETH");
        require(price_ > 0, "Price cannot be zero");
        require(price_ >= faceValue_/1000, "Price cannot be too low (< 0.1% of face value)");
        require(numYears_ <= 30, "Bond duration should not exceed 30 years");
        _totalQuantity = totalQuantity_;
        _faceValue = faceValue_;
        _price = price_;
        _numYears = numYears_;
        _startBlock = block.timestamp;
        _maturityBlock = _startBlock + _numYears * 365 * 1 days;
        _owner = msg.sender;
        _currState = BondState.ACTIVATED;
        _vault = vault_;

    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if (block.timestamp > _maturityBlock && _currState==BondState.ACTIVATED) {
            if(fulfilled()){
                _currState=BondState.COMPLETED;
                emit Completed(address(this), _owner);
            } else {
                _currState=BondState.DEFAULTED;
                liquidate();
                emit Defaulted(address(this), _owner);
            }
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }


    function decimals() public view virtual override returns (uint8) {
        return 3;
    }

    function purchase(uint256 quantity_) external payable{
        require(msg.sender!=_owner, "Owner cannot purchase bond");
        uint256 amount = _price * quantity_ / 1000;
        require(msg.value >= amount, "Insufficient ETH sent to purchase bond");
        require(_purchasedQuantity+quantity_ <= _totalQuantity, "Exceeded total quantity");
        require(_currState==BondState.ACTIVATED, "Bond is inactive");
        require(block.timestamp <= _cooldownPeriod + _startBlock, "Bond no longer available for sale" );
        if (msg.value > amount){
            uint256 excess = msg.value - amount;
            (bool success, ) = payable(msg.sender).call{value: excess}("");
            require(success, "Failed");
        }

        _purchasedQuantity+=quantity_;
        _mint(msg.sender, quantity_);
    }

    function redeem() external payable {
        require(_currState==BondState.COMPLETED, "Bond is incomplete");
        require(balanceOf(msg.sender)>0, "Caller did not purchase bond");
        uint256 amount = _faceValue * balanceOf(msg.sender) / 1000;

        _burn(msg.sender, balanceOf(msg.sender));
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "Failed");


    }

    function liquidate() internal {
        require(_currState==BondState.DEFAULTED, "Bond is not defaulted");
        require(address(this).balance>0, "No funds to liquidate");
        uint256 amount = address(this).balance;
        (bool success, ) = payable(_vault).call{value: amount}("");
        require(success, "Failed");
    }

    function fund() external payable {
        require(_currState==BondState.ACTIVATED, "Bond is inactive");
        require(msg.sender==_owner, "Only owner can fund");
        require(block.timestamp > _cooldownPeriod + _startBlock, "Sale has not ended" );
        require(msg.value > 0, "Zero ETH sent");

    }

    function withdraw(uint256 amount_) external {
        require(_currState==BondState.ACTIVATED, "Bond is inactive");
        require(msg.sender==_owner, "Only owner can withdraw");
        require(block.timestamp > _cooldownPeriod + _startBlock, "Sale has not ended" );
        require(amount_ <= address(this).balance, "Requested withdrawal exceeds ETH balance");
        (bool success, ) = payable(msg.sender).call{value: amount_}("");
        require(success, "Failed");
    }

    function activeDefault() external {
        require(_currState==BondState.ACTIVATED, "Bond is inactive");
        require(msg.sender==_owner, "Only owner can default");
        _currState = BondState.DEFAULTED;
    }

    function transferOwnership(address account_) public {
        require(!_ownershipTransferred, "Ownership is already transferred");
        require(msg.sender==_owner, "Only owner can transfer ownership");
        _owner = account_;
        _ownershipTransferred=true;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp > _maturityBlock && _currState==BondState.ACTIVATED);
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function fulfilled() public view returns(bool){
        return address(this).balance >= _faceValue * _purchasedQuantity / 1000;
    }

    function fulfillAmount() public view returns(uint256){
        return _faceValue * _purchasedQuantity / 1000;
    }

    function owner() public view returns(address) {
        return _owner;
    }

    function currState() public view returns(BondState) {
        return _currState;
    }

    function coolDownPeriod() public pure returns(uint256) {
        return _cooldownPeriod;
    }

    function isOngoingSale() public view returns(bool) {
        return block.timestamp <= (_cooldownPeriod + _startBlock);
    }

    function minFaceValue() public pure returns(uint256) {
        return _minFaceValue;
    }

    function totalQuantity() public view returns(uint256) {
        return _totalQuantity;
    }

    function purchasedQuantity() public view returns(uint256) {
        return _purchasedQuantity;
    }

    function faceValue() public view returns(uint256) {
        return _faceValue;
    }
    
    function price() public view returns(uint256) {
        return _price;
    }

    function numYears() public view returns(uint256) {
        return _numYears;
    }

    function startBlock() public view returns(uint256) {
        return _startBlock;
    }

    function maturityBlock() public view returns(uint256) {
        return _maturityBlock;
    }

    function cooldownBlock() public view returns(uint256) {
        return _cooldownPeriod + _startBlock;
    }

    function metadata() public view returns(string memory, string memory, address, uint256, uint256, uint256, uint256, uint256) {
        return (name(), symbol(), _owner, _price, _faceValue, _numYears, _totalQuantity, _purchasedQuantity);
    }

    function status() public view returns(bool,bool,uint256,BondState, uint256, uint256, uint256) {
        return (isOngoingSale(), fulfilled(), fulfillAmount(), currState(), cooldownBlock(), _startBlock, _maturityBlock);
    }

}
